<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æª”æ¡ˆç·¨ç¢¼è§£ç¢¼å·¥å…· - å°ˆæ¥­ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #17a2b8;
            --light-gray: #ecf0f1;
            --dark-gray: #7f8c8d;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'Microsoft JhengHei', 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            box-shadow: var(--shadow);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 40px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        .header h1 {
            font-size: 2.8em;
            margin-bottom: 15px;
            font-weight: 300;
            position: relative;
            z-index: 1;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        .main-content {
            padding: 50px 40px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
        }

        .tool-section {
            background: white;
            border-radius: 20px;
            padding: 35px;
            box-shadow: var(--shadow);
            border: 1px solid rgba(0,0,0,0.05);
            transition: var(--transition);
            position: relative;
        }

        .tool-section:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .section-title {
            font-size: 2em;
            color: var(--primary-color);
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid var(--secondary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-input-area {
            border: 3px dashed var(--secondary-color);
            border-radius: 15px;
            padding: 50px 30px;
            text-align: center;
            margin-bottom: 25px;
            transition: var(--transition);
            cursor: pointer;
            position: relative;
            background: linear-gradient(45deg, transparent 0%, rgba(52, 152, 219, 0.02) 100%);
        }

        .file-input-area:hover {
            border-color: #2980b9;
            background: rgba(52, 152, 219, 0.08);
            transform: scale(1.02);
        }

        .file-input-area.dragover {
            border-color: var(--success-color);
            background: rgba(46, 204, 113, 0.15);
            transform: scale(1.05);
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            font-size: 1.3em;
            color: var(--secondary-color);
            cursor: pointer;
            display: block;
            font-weight: 500;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            opacity: 0.7;
        }

        .file-info {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(155, 89, 182, 0.1) 100%);
            border-radius: 12px;
            font-size: 0.95em;
            color: var(--primary-color);
            border: 1px solid rgba(52, 152, 219, 0.2);
        }

        .text-area {
            width: 100%;
            min-height: 250px;
            max-height: 400px;
            padding: 25px;
            border: 2px solid #e1e8ed;
            border-radius: 15px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            resize: vertical;
            transition: var(--transition);
            background: #fafbfc;
        }

        .text-area:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.1);
            background: white;
        }

        .button {
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 50px;
            font-size: 1.05em;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            margin: 8px;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.3);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .button:hover::before {
            left: 100%;
        }

        .button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(52, 152, 219, 0.4);
        }

        .button:active {
            transform: translateY(-1px);
        }

        .button.danger {
            background: linear-gradient(135deg, var(--danger-color), #c0392b);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.3);
        }

        .button.danger:hover {
            box-shadow: 0 15px 35px rgba(231, 76, 60, 0.4);
        }

        .button.success {
            background: linear-gradient(135deg, var(--success-color), #229954);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.3);
        }

        .button.success:hover {
            box-shadow: 0 15px 35px rgba(39, 174, 96, 0.4);
        }

        .button.warning {
            background: linear-gradient(135deg, var(--warning-color), #e67e22);
            box-shadow: 0 8px 25px rgba(243, 156, 18, 0.3);
        }

        .button.warning:hover {
            box-shadow: 0 15px 35px rgba(243, 156, 18, 0.4);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .button-group {
            text-align: center;
            margin: 25px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .status-message {
            padding: 18px 25px;
            margin: 20px 0;
            border-radius: 12px;
            font-weight: 600;
            text-align: center;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .status-success {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.15), rgba(39, 174, 96, 0.05));
            color: #1e8449;
            border: 2px solid rgba(39, 174, 96, 0.3);
        }

        .status-error {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.15), rgba(231, 76, 60, 0.05));
            color: #c0392b;
            border: 2px solid rgba(231, 76, 60, 0.3);
        }

        .status-info {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.15), rgba(52, 152, 219, 0.05));
            color: #2980b9;
            border: 2px solid rgba(52, 152, 219, 0.3);
        }

        .status-warning {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.15), rgba(243, 156, 18, 0.05));
            color: #d68910;
            border: 2px solid rgba(243, 156, 18, 0.3);
        }

        .progress-container {
            margin: 20px 0;
            padding: 20px;
            background: rgba(52, 152, 219, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary-color), #2980b9);
            width: 0%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image: linear-gradient(
                -45deg,
                rgba(255, 255, 255, 0.2) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.2) 75%,
                transparent 75%,
                transparent
            );
            background-size: 50px 50px;
            animation: progressMove 1s linear infinite;
        }

        @keyframes progressMove {
            0% { background-position: 0 0; }
            100% { background-position: 50px 50px; }
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .encoding-format {
            display: flex;
            gap: 20px;
            margin: 25px 0;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .format-option {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            cursor: pointer;
            padding: 12px 20px;
            border-radius: 25px;
            transition: var(--transition);
            border: 2px solid transparent;
            background: rgba(52, 152, 219, 0.05);
        }

        .format-option:hover {
            background: rgba(52, 152, 219, 0.1);
            transform: scale(1.05);
        }

        .format-option input[type="radio"] {
            accent-color: var(--secondary-color);
            transform: scale(1.2);
        }

        .format-option input[type="radio"]:checked + .format-label {
            color: var(--secondary-color);
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
            animation: fadeInUp 0.5s ease-out;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .stat-item {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.08), rgba(155, 89, 182, 0.05));
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(52, 152, 219, 0.1);
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--secondary-color), #2980b9);
        }

        .stat-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(52, 152, 219, 0.15);
        }

        .stat-value {
            font-size: 2.2em;
            font-weight: 700;
            color: var(--secondary-color);
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            color: var(--dark-gray);
            font-size: 0.95em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .advanced-options {
            margin: 25px 0;
            padding: 20px;
            background: rgba(52, 152, 219, 0.03);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }

        .advanced-toggle {
            cursor: pointer;
            font-weight: 600;
            color: var(--secondary-color);
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .advanced-content {
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .advanced-content.show {
            display: block;
        }

        @keyframes slideDown {
            from { opacity: 0; max-height: 0; }
            to { opacity: 1; max-height: 200px; }
        }

        .chunk-size-selector {
            margin: 15px 0;
        }

        .chunk-size-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .chunk-size-selector input {
            width: 100px;
            padding: 8px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1001;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success { background: var(--success-color); }
        .toast.error { background: var(--danger-color); }
        .toast.info { background: var(--info-color); }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
            position: relative;
        }

        @keyframes modalSlideIn {
            from { opacity: 0; transform: scale(0.8) translateY(-50px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light-gray);
        }

        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: var(--dark-gray);
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--light-gray);
            color: var(--danger-color);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 1em;
            transition: var(--transition);
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.1);
        }

        .form-select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 1em;
            transition: var(--transition);
            background: white;
            cursor: pointer;
        }

        .form-select:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.1);
        }

        .file-preview {
            background: rgba(52, 152, 219, 0.05);
            border: 1px solid rgba(52, 152, 219, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .file-preview-info {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            align-items: center;
            font-size: 0.9em;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 30px;
        }

        .modal-button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .modal-button.primary {
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            color: white;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .modal-button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .modal-button.secondary {
            background: var(--light-gray);
            color: var(--dark-gray);
        }

        .modal-button.secondary:hover {
            background: #bdc3c7;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 30px;
                padding: 40px 30px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 30px 20px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2em;
            }
            
            .tool-section {
                padding: 25px 20px;
            }

            .button-group {
                flex-direction: column;
                align-items: center;
            }

            .button {
                width: 100%;
                max-width: 300px;
            }

            .stats {
                grid-template-columns: 1fr;
            }
        }

        .performance-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(39, 174, 96, 0.1);
            color: var(--success-color);
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <div class="container">
        <div class="header">
            <h1>ğŸ” æª”æ¡ˆç·¨ç¢¼è§£ç¢¼å·¥å…·</h1>
            <p>å°ˆæ¥­ç´šæª”æ¡ˆè½‰æ›å·¥å…·ï¼Œæ”¯æ´å¤§æª”æ¡ˆè™•ç†èˆ‡å¤šç¨®æ ¼å¼ï¼Œå®Œå…¨é›¢ç·šé‹ä½œ</p>
            <div class="performance-indicator">é«˜æ•ˆèƒ½ç‰ˆæœ¬</div>
        </div>

        <div class="main-content">
            <!-- ç·¨ç¢¼å€åŸŸ -->
            <div class="tool-section">
                <h2 class="section-title">
                    ğŸ“¤ æª”æ¡ˆç·¨ç¢¼
                </h2>
                
                <div class="encoding-format">
                    <span style="font-weight: 600;">ç·¨ç¢¼æ ¼å¼ï¼š</span>
                    <label class="format-option">
                        <input type="radio" name="encodeFormat" value="base64" checked>
                        <span class="format-label">Base64</span>
                    </label>
                    <label class="format-option">
                        <input type="radio" name="encodeFormat" value="hex">
                        <span class="format-label">åå…­é€²ä½</span>
                    </label>
                    <label class="format-option">
                        <input type="radio" name="encodeFormat" value="base32">
                        <span class="format-label">Base32</span>
                    </label>
                </div>

                <div class="advanced-options">
                    <div class="advanced-toggle" onclick="toggleAdvanced('encode')">
                        âš™ï¸ é€²éšé¸é …
                        <span id="encodeAdvancedIcon">â–¼</span>
                    </div>
                    <div class="advanced-content" id="encodeAdvanced">
                        <div class="chunk-size-selector">
                            <label>åˆ†å¡Šå¤§å° (MBï¼Œç”¨æ–¼å¤§æª”æ¡ˆè™•ç†):</label>
                            <input type="number" id="encodeChunkSize" value="10" min="1" max="100">
                        </div>
                        <label>
                            <input type="checkbox" id="addTimestamp"> æ·»åŠ æ™‚é–“æˆ³è¨˜
                        </label>
                        <br>
                        <label>
                            <input type="checkbox" id="enableCompression"> åœ¨ç·¨ç¢¼å‰é€²è¡Œ gzip å£“ç¸®
                        </label>
                        <div style="font-size: 0.9em; margin-left: 24px; opacity: 0.7;">
                            å£“ç¸®æœƒå¢åŠ  CPU ä½¿ç”¨ç‡ä½†å¯èƒ½æ¸›å°‘è¼¸å‡ºå¤§å°
                        </div>
                        <br>
                        <label>
                            <input type="checkbox" id="enableEncryption" onclick="document.getElementById('encryptionPassword').style.display = this.checked ? 'block' : 'none';"> å•Ÿç”¨åŠ å¯†
                        </label>
                        <input type="password" id="encryptionPassword" placeholder="è¼¸å…¥å¯†ç¢¼" style="display:none; margin-top:5px;">
                    </div>
                </div>

                <div class="file-input-area" id="encodeDropArea">
                    <input type="file" id="encodeFile" class="file-input">
                    <label for="encodeFile" class="file-input-label">
                        <div class="upload-icon">ğŸ“</div>
                        é»æ“Šé¸æ“‡æª”æ¡ˆæˆ–æ‹–æ”¾æª”æ¡ˆåˆ°æ­¤è™•
                        <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
                            æ”¯æ´ä»»ä½•æ ¼å¼ï¼Œç„¡å¤§å°é™åˆ¶
                        </div>
                    </label>
                    <div id="encodeFileInfo" class="file-info" style="display: none;"></div>
                </div>

                <div class="button-group">
                    <button class="button" onclick="encodeFile()" id="encodeBtn">
                        ğŸ” é–‹å§‹ç·¨ç¢¼
                    </button>
                    <button class="button danger" onclick="clearEncode()">
                        ğŸ—‘ï¸ æ¸…é™¤
                    </button>
                </div>

                <div class="progress-container" id="encodeProgressContainer" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="encodeProgressFill"></div>
                    </div>
                    <div class="progress-text" id="encodeProgressText">è™•ç†ä¸­...</div>
                </div>

                <div id="encodeStatus"></div>

                <textarea id="encodedText" class="text-area" placeholder="ç·¨ç¢¼çµæœï¼ˆJSON æ ¼å¼ï¼‰å°‡é¡¯ç¤ºåœ¨é€™è£¡..." readonly></textarea>

                <div class="button-group">
                    <button class="button success" onclick="copyEncoded()">
                        ğŸ“‹ è¤‡è£½ç·¨ç¢¼çµæœ
                    </button>
                    <button class="button" onclick="downloadEncoded()">
                        ğŸ’¾ ä¸‹è¼‰ç‚º JSON æª”
                    </button>
                    <button class="button warning" onclick="validateEncoded()">
                        âœ“ é©—è­‰ç·¨ç¢¼
                    </button>
                </div>

                <div class="stats" id="encodeStats" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-value" id="originalSize">0</div>
                        <div class="stat-label">åŸå§‹å¤§å° (bytes)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="encodedSize">0</div>
                        <div class="stat-label">ç·¨ç¢¼å¾Œå¤§å° (bytes)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="sizeRatio">0%</div>
                        <div class="stat-label">å¤§å°æ¯”ä¾‹</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="processingTime">0</div>
                        <div class="stat-label">è™•ç†æ™‚é–“ (ç§’)</div>
                    </div>
                </div>
            </div>

            <!-- è§£ç¢¼å€åŸŸ -->
            <div class="tool-section">
                <h2 class="section-title">
                    ğŸ“¥ æ–‡å­—è§£ç¢¼
                </h2>
                
                <div class="encoding-format">
                    <span style="font-weight: 600;">è§£ç¢¼æ ¼å¼ï¼š</span>
                    <label class="format-option">
                        <input type="radio" name="decodeFormat" value="base64" checked>
                        <span class="format-label">Base64</span>
                    </label>
                    <label class="format-option">
                        <input type="radio" name="decodeFormat" value="hex">
                        <span class="format-label">åå…­é€²ä½</span>
                    </label>
                    <label class="format-option">
                        <input type="radio" name="decodeFormat" value="base32">
                        <span class="format-label">Base32</span>
                    </label>
                    <label class="format-option">
                        <input type="radio" name="decodeFormat" value="auto">
                        <span class="format-label">è‡ªå‹•åµæ¸¬</span>
                    </label>
                </div>

                <div class="advanced-options">
                    <div class="advanced-toggle" onclick="toggleAdvanced('decode')">
                        âš™ï¸ é€²éšé¸é …
                        <span id="decodeAdvancedIcon">â–¼</span>
                    </div>
                    <div class="advanced-content" id="decodeAdvanced">
                        <label>
                            <input type="checkbox" id="validateIntegrity" checked> é©—è­‰è³‡æ–™å®Œæ•´æ€§
                        </label>
                        <br><br>
                        <label>
                            <input type="checkbox" id="autoDetectFormat" checked> è‡ªå‹•åµæ¸¬æ ¼å¼
                        </label>
                        <br>
                        <label>
                            <input type="checkbox" id="decompressGzip" checked> è‹¥ç‚º gzip å£“ç¸®å‰‡è‡ªå‹•è§£å£“
                        </label>
                        <div style="font-size: 0.9em; margin-left: 24px; opacity: 0.7;">
                            è§£å£“ç¸®éœ€é¡å¤– CPU è³‡æº
                        </div>
                        <br>
                        <label>
                            <input type="checkbox" id="enableDecryption" onclick="document.getElementById('decryptionPassword').style.display = this.checked ? 'block' : 'none';"> å•Ÿç”¨è§£å¯†
                        </label>
                        <input type="password" id="decryptionPassword" placeholder="è¼¸å…¥å¯†ç¢¼" style="display:none; margin-top:5px;">
                    </div>
                </div>

                <textarea id="decodeText" class="text-area" placeholder="è²¼ä¸Šè¦è§£ç¢¼çš„ JSON å…§å®¹æˆ–å¾æª”æ¡ˆè¼‰å…¥..."></textarea>

                <div class="button-group">
                    <button class="button" onclick="decodeText()" id="decodeBtn">
                        ğŸ”“ é–‹å§‹è§£ç¢¼
                    </button>
                    <button class="button" onclick="loadFromFile()">
                        ğŸ“‚ è¼‰å…¥ JSON æª”
                    </button>
                    <button class="button danger" onclick="clearDecode()">
                        ğŸ—‘ï¸ æ¸…é™¤
                    </button>
                </div>

                <div class="progress-container" id="decodeProgressContainer" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="decodeProgressFill"></div>
                    </div>
                    <div class="progress-text" id="decodeProgressText">è§£ç¢¼ä¸­...</div>
                </div>

                <div id="decodeStatus"></div>

                <div class="button-group" id="decodeButtons" style="display: none;">
                    <button class="button success" onclick="downloadDecoded()">
                        ğŸ’¾ ä¸‹è¼‰è§£ç¢¼æª”æ¡ˆ
                    </button>
                    <button class="button warning" onclick="saveAsDecoded()">
                        ğŸ“ å¦å­˜æ–°æª”
                    </button>
                    <button class="button" onclick="previewDecoded()">
                        ğŸ‘ï¸ é è¦½æª”æ¡ˆ
                    </button>
                </div>

                <div class="stats" id="decodeStats" style="display: none;">
                    <div class="stat-item">
                        <div class="stat-value" id="decodedSize">0</div>
                        <div class="stat-label">è§£ç¢¼å¾Œå¤§å° (bytes)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="decodedType">Unknown</div>
                        <div class="stat-label">æª”æ¡ˆé¡å‹</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="decodeTime">0</div>
                        <div class="stat-label">è§£ç¢¼æ™‚é–“ (ç§’)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="hiddenFileInput" style="display: none;">

    <!-- å¦å­˜æ–°æª”å½ˆå‡ºè¦–çª— -->
    <div class="modal" id="saveAsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">
                    ğŸ“ å¦å­˜æ–°æª”
                </div>
                <button class="modal-close" onclick="closeSaveAsModal()">Ã—</button>
            </div>
            
            <div class="file-preview" id="filePreviewInfo">
                <div class="file-preview-info">
                    <span><strong>æª”æ¡ˆé¡å‹ï¼š</strong></span>
                    <span id="previewFileType">-</span>
                    <span><strong>æª”æ¡ˆå¤§å°ï¼š</strong></span>
                    <span id="previewFileSize">-</span>
                    <span><strong>é ä¼°æ ¼å¼ï¼š</strong></span>
                    <span id="previewFileFormat">-</span>
                </div>
            </div>
            
            <div class="form-group">
                <label class="form-label" for="saveFileName">æª”æ¡ˆåç¨±ï¼š</label>
                <input type="text" id="saveFileName" class="form-input" placeholder="è¼¸å…¥æª”æ¡ˆåç¨±..." />
            </div>
            
            <div class="form-group">
                <label class="form-label" for="saveFileExtension">æª”æ¡ˆæ ¼å¼ï¼š</label>
                <select id="saveFileExtension" class="form-select">
                    <option value="auto">ğŸ” è‡ªå‹•åµæ¸¬</option>
                    <optgroup label="ğŸ“· åœ–ç‰‡æ ¼å¼">
                        <option value=".png">PNG åœ–ç‰‡ (.png)</option>
                        <option value=".jpg">JPEG åœ–ç‰‡ (.jpg)</option>
                        <option value=".gif">GIF åœ–ç‰‡ (.gif)</option>
                        <option value=".bmp">BMP åœ–ç‰‡ (.bmp)</option>
                        <option value=".webp">WebP åœ–ç‰‡ (.webp)</option>
                    </optgroup>
                    <optgroup label="ğŸ“„ æ–‡ä»¶æ ¼å¼">
                        <option value=".pdf">PDF æ–‡ä»¶ (.pdf)</option>
                        <option value=".doc">Word æ–‡ä»¶ (.doc)</option>
                        <option value=".docx">Word æ–‡ä»¶ (.docx)</option>
                        <option value=".xls">Excel æ–‡ä»¶ (.xls)</option>
                        <option value=".xlsx">Excel æ–‡ä»¶ (.xlsx)</option>
                        <option value=".ppt">PowerPoint (.ppt)</option>
                        <option value=".pptx">PowerPoint (.pptx)</option>
                        <option value=".txt">ç´”æ–‡å­— (.txt)</option>
                        <option value=".rtf">RTF æ–‡ä»¶ (.rtf)</option>
                    </optgroup>
                    <optgroup label="ğŸ—œï¸ å£“ç¸®æ ¼å¼">
                        <option value=".zip">ZIP å£“ç¸®æª” (.zip)</option>
                        <option value=".rar">RAR å£“ç¸®æª” (.rar)</option>
                        <option value=".7z">7Z å£“ç¸®æª” (.7z)</option>
                        <option value=".gz">GZIP æª”æ¡ˆ (.gz)</option>
                        <option value=".tar">TAR æª”æ¡ˆ (.tar)</option>
                    </optgroup>
                    <optgroup label="ğŸµ å¤šåª’é«”æ ¼å¼">
                        <option value=".mp3">MP3 éŸ³æ¨‚ (.mp3)</option>
                        <option value=".wav">WAV éŸ³æ¨‚ (.wav)</option>
                        <option value=".flac">FLAC éŸ³æ¨‚ (.flac)</option>
                        <option value=".mp4">MP4 å½±ç‰‡ (.mp4)</option>
                        <option value=".avi">AVI å½±ç‰‡ (.avi)</option>
                        <option value=".mkv">MKV å½±ç‰‡ (.mkv)</option>
                    </optgroup>
                    <optgroup label="ğŸ’¾ ç¨‹å¼/è³‡æ–™">
                        <option value=".exe">åŸ·è¡Œæª” (.exe)</option>
                        <option value=".msi">å®‰è£ç¨‹å¼ (.msi)</option>
                        <option value=".dll">å‹•æ…‹é€£çµåº« (.dll)</option>
                        <option value=".json">JSON è³‡æ–™ (.json)</option>
                        <option value=".xml">XML è³‡æ–™ (.xml)</option>
                        <option value=".csv">CSV è³‡æ–™ (.csv)</option>
                        <option value=".sql">SQL æª”æ¡ˆ (.sql)</option>
                    </optgroup>
                    <optgroup label="ğŸ”§ å…¶ä»–æ ¼å¼">
                        <option value=".bin">äºŒé€²ä½æª”æ¡ˆ (.bin)</option>
                        <option value=".dat">è³‡æ–™æª”æ¡ˆ (.dat)</option>
                        <option value=".bak">å‚™ä»½æª”æ¡ˆ (.bak)</option>
                        <option value=".tmp">æš«å­˜æª”æ¡ˆ (.tmp)</option>
                        <option value="">ç„¡å‰¯æª”å</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="modal-buttons">
                <button class="modal-button secondary" onclick="closeSaveAsModal()">
                    å–æ¶ˆ
                </button>
                <button class="modal-button primary" onclick="confirmSaveAs()">
                    ä¸‹è¼‰æª”æ¡ˆ
                </button>
            </div>
        </div>
    </div>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let decodedData = null;
        let originalFileName = '';
        let processingStartTime = 0;
        let currentAbortController = null;

        // Base32 ç·¨ç¢¼è¡¨
        const BASE32_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

        // å·¥å…·å‡½æ•¸
        class FileProcessor {
            static async *processInChunks(file, chunkSize = 10 * 1024 * 1024, progressCallback) {
                const totalChunks = Math.ceil(file.size / chunkSize);

                for (let i = 0; i < totalChunks; i++) {
                    if (currentAbortController?.signal.aborted) {
                        throw new Error('æ“ä½œå·²å–æ¶ˆ');
                    }

                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, file.size);
                    const chunk = file.slice(start, end);
                    const arrayBuffer = await chunk.arrayBuffer();

                    if (progressCallback) {
                        progressCallback((i + 1) / totalChunks * 100);
                    }

                    // è®“ç€è¦½å™¨æœ‰æ©Ÿæœƒæ›´æ–°UI
                    await new Promise(resolve => setTimeout(resolve, 0));

                    yield new Uint8Array(arrayBuffer);
                }
            }

            static detectFormat(text) {
                text = text.trim();
                
                // Base64 æª¢æ¸¬
                if (/^[A-Za-z0-9+/]*={0,2}$/.test(text) && text.length % 4 === 0) {
                    return 'base64';
                }
                
                // åå…­é€²ä½æª¢æ¸¬
                if (/^[0-9A-Fa-f]*$/.test(text) && text.length % 2 === 0) {
                    return 'hex';
                }
                
                // Base32 æª¢æ¸¬
                if (/^[A-Z2-7]*={0,6}$/.test(text.toUpperCase()) && text.length % 8 === 0) {
                    return 'base32';
                }
                
                return 'unknown';
            }

            static validateIntegrity(originalData, processedData) {
                return originalData.byteLength === processedData.byteLength;
            }
        }

        // Base32 ç·¨ç¢¼è§£ç¢¼å‡½æ•¸
        function arrayBufferToBase32(buffer) {
            const bytes = new Uint8Array(buffer);
            let result = '';
            
            for (let i = 0; i < bytes.length; i += 5) {
                const chunk = bytes.slice(i, i + 5);
                let value = 0;
                
                for (let j = 0; j < chunk.length; j++) {
                    value = (value << 8) | chunk[j];
                }
                
                const padding = 5 - chunk.length;
                if (padding > 0) {
                    value <<= padding * 8;
                }
                
                for (let j = 0; j < 8; j++) {
                    if (j >= Math.ceil(chunk.length * 8 / 5)) {
                        // å°æ–¼ä¸è¶³ 5 ä½å…ƒçµ„çš„æœ€å¾Œä¸€å¡Šï¼Œéœ€è¦è£œ '=' åšç‚ºå¡«å……
                        result += '=';
                    } else {
                        const index = (value >>> (35 - j * 5)) & 0x1F;
                        result += BASE32_ALPHABET[index];
                    }
                }
            }
            
            return result;
        }

        function base32ToArrayBuffer(base32) {
            base32 = base32.toUpperCase().replace(/=/g, '');
            const bytes = [];
            
            for (let i = 0; i < base32.length; i += 8) {
                let value = 0;
                const chunk = base32.slice(i, i + 8);
                
                for (let j = 0; j < chunk.length; j++) {
                    const index = BASE32_ALPHABET.indexOf(chunk[j]);
                    if (index === -1) throw new Error('ç„¡æ•ˆçš„Base32å­—å…ƒ');
                    value = (value << 5) | index;
                }
                
                for (let j = 0; j < 5 && bytes.length < Math.floor(base32.length * 5 / 8); j++) {
                    bytes.push((value >>> (32 - (j + 1) * 8)) & 0xFF);
                }
            }
            
            return new Uint8Array(bytes).buffer;
        }

        // æ‹–æ”¾åŠŸèƒ½è¨­å®š
        const encodeDropArea = document.getElementById('encodeDropArea');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            encodeDropArea.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            encodeDropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            encodeDropArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
            encodeDropArea.classList.add('dragover');
        }

        function unhighlight(e) {
            encodeDropArea.classList.remove('dragover');
        }

        encodeDropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                document.getElementById('encodeFile').files = files;
                showFileInfo(files[0]);
            }
        }

        // æª”æ¡ˆé¸æ“‡äº‹ä»¶
        document.getElementById('encodeFile').addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                showFileInfo(e.target.files[0]);
            }
        });

        function showFileInfo(file) {
            const fileInfo = document.getElementById('encodeFileInfo');
            const fileType = detectAdvancedFileType(file);
            
            fileInfo.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left;">
                    <div><strong>æª”æ¡ˆåç¨±ï¼š</strong><br>${file.name}</div>
                    <div><strong>æª”æ¡ˆå¤§å°ï¼š</strong><br>${formatBytes(file.size)}</div>
                    <div><strong>æª”æ¡ˆé¡å‹ï¼š</strong><br>${file.type || 'æœªçŸ¥'}</div>
                    <div><strong>æœ€å¾Œä¿®æ”¹ï¼š</strong><br>${new Date(file.lastModified).toLocaleString('zh-TW')}</div>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: rgba(39, 174, 96, 0.1); border-radius: 6px;">
                    <strong>é ä¼°ç·¨ç¢¼å¾Œå¤§å°ï¼š</strong> ${formatBytes(Math.ceil(file.size * 1.37))} (Base64)
                </div>
            `;
            fileInfo.style.display = 'block';
            originalFileName = file.name;
        }

        function detectAdvancedFileType(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            const typeMap = {
                'jpg': 'JPEG åœ–ç‰‡', 'jpeg': 'JPEG åœ–ç‰‡', 'png': 'PNG åœ–ç‰‡', 'gif': 'GIF åœ–ç‰‡',
                'pdf': 'PDF æ–‡ä»¶', 'doc': 'Word æ–‡ä»¶', 'docx': 'Word æ–‡ä»¶',
                'xls': 'Excel æ–‡ä»¶', 'xlsx': 'Excel æ–‡ä»¶', 'ppt': 'PowerPoint æ–‡ä»¶',
                'zip': 'ZIP å£“ç¸®æª”', 'rar': 'RAR å£“ç¸®æª”', '7z': '7Z å£“ç¸®æª”',
                'mp3': 'MP3 éŸ³æ¨‚', 'wav': 'WAV éŸ³æ¨‚', 'mp4': 'MP4 å½±ç‰‡', 'avi': 'AVI å½±ç‰‡'
            };
            return typeMap[ext] || 'æœªçŸ¥é¡å‹';
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        // Encryption utilities using Web Crypto API
        async function deriveKey(password, salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                enc.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                {
                    name: 'AES-GCM',
                    length: 256
                },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function encryptData(data, password) {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt);
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv },
                key,
                data
            );
            const result = new Uint8Array(salt.byteLength + iv.byteLength + encrypted.byteLength);
            result.set(salt, 0);
            result.set(iv, salt.byteLength);
            result.set(new Uint8Array(encrypted), salt.byteLength + iv.byteLength);
            return result.buffer;
        }

        async function decryptData(data, password) {
            const dataArray = new Uint8Array(data);
            const salt = dataArray.slice(0, 16);
            const iv = dataArray.slice(16, 28);
            const ciphertext = dataArray.slice(28);
            const key = await deriveKey(password, salt);
            return crypto.subtle.decrypt(
                { name: 'AES-GCM', iv },
                key,
                ciphertext
            );
        }

        async function encodeFile() {
            const fileInput = document.getElementById('encodeFile');
            const file = fileInput.files[0];
            
            if (!file) {
                showStatus('encodeStatus', 'âŒ è«‹é¸æ“‡è¦ç·¨ç¢¼çš„æª”æ¡ˆ', 'error');
                return;
            }

            const format = document.querySelector('input[name="encodeFormat"]:checked').value;
            const chunkSize = parseInt(document.getElementById('encodeChunkSize').value) * 1024 * 1024;
            const addTimestamp = document.getElementById('addTimestamp').checked;
            const enableCompression = document.getElementById('enableCompression').checked;
            
            processingStartTime = Date.now();
            currentAbortController = new AbortController();
            
            const progressContainer = document.getElementById('encodeProgressContainer');
            const progressFill = document.getElementById('encodeProgressFill');
            const progressText = document.getElementById('encodeProgressText');
            const encodeBtn = document.getElementById('encodeBtn');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            encodeBtn.disabled = true;
            encodeBtn.innerHTML = 'â¹ï¸ å–æ¶ˆè™•ç†';
            encodeBtn.onclick = () => {
                currentAbortController.abort();
                encodeBtn.disabled = false;
                encodeBtn.innerHTML = 'ğŸ” é–‹å§‹ç·¨ç¢¼';
                encodeBtn.onclick = encodeFile;
                progressContainer.style.display = 'none';
            };
            
            const uint8ToBinaryString = (uint8) => {
                let binary = '';
                const CHUNK_SIZE = 0x8000;
                for (let i = 0; i < uint8.length; i += CHUNK_SIZE) {
                    binary += String.fromCharCode(...uint8.subarray(i, i + CHUNK_SIZE));
                }
                return binary;
            };

            const encodeBase64Chunk = (chunk, carry) => {
                let buffer;
                if (carry.length) {
                    buffer = new Uint8Array(carry.length + chunk.length);
                    buffer.set(carry);
                    buffer.set(chunk, carry.length);
                } else {
                    buffer = chunk;
                }
                const remain = buffer.length % 3;
                const toEncode = buffer.subarray(0, buffer.length - remain);
                const newCarry = buffer.slice(buffer.length - remain);
                const output = btoa(uint8ToBinaryString(toEncode));
                return { output, carry: newCarry };
            };

            const finalizeBase64 = (carry) => {
                if (!carry.length) return '';
                return btoa(uint8ToBinaryString(carry));
            };

            const encodeBase32Chunk = (chunk, carry) => {
                let buffer;
                if (carry.length) {
                    buffer = new Uint8Array(carry.length + chunk.length);
                    buffer.set(carry);
                    buffer.set(chunk, carry.length);
                } else {
                    buffer = chunk;
                }
                let result = '';
                let i = 0;
                while (i + 5 <= buffer.length) {
                    const part = buffer.subarray(i, i + 5);
                    let value = 0;
                    for (let j = 0; j < 5; j++) {
                        value = (value << 8) | part[j];
                    }
                    for (let j = 0; j < 8; j++) {
                        const index = (value >>> (35 - j * 5)) & 0x1F;
                        result += BASE32_ALPHABET[index];
                    }
                    i += 5;
                }
                const newCarry = buffer.slice(i);
                return { output: result, carry: newCarry };
            };

            const finalizeBase32 = (carry) => {
                if (!carry.length) return '';
                let value = 0;
                for (let i = 0; i < carry.length; i++) {
                    value = (value << 8) | carry[i];
                }
                const padding = 5 - carry.length;
                value <<= padding * 8;
                let result = '';
                for (let j = 0; j < 8; j++) {
                    if (j >= Math.ceil(carry.length * 8 / 5)) {
                        result += '=';
                    } else {
                        const index = (value >>> (35 - j * 5)) & 0x1F;
                        result += BASE32_ALPHABET[index];
                    }
                }
                return result;
            };

            const compressChunk = async (chunk) => {
                if (typeof CompressionStream !== 'undefined') {
                    const cs = new CompressionStream('gzip');
                    const writer = cs.writable.getWriter();
                    await writer.write(chunk);
                    await writer.close();
                    const compressed = await new Response(cs.readable).arrayBuffer();
                    return new Uint8Array(compressed);
                }
                throw new Error('ç€è¦½å™¨ä¸æ”¯æ´ gzip å£“ç¸®');
            };

            if (enableCompression) {
                showStatus('encodeStatus', 'ğŸ” æ­£åœ¨å£“ç¸®ä¸¦ç·¨ç¢¼...', 'info');
                progressText.textContent = 'æ­£åœ¨å£“ç¸®ä¸¦ç·¨ç¢¼...';
            } else {
                showStatus('encodeStatus', 'ğŸ” æ­£åœ¨ç·¨ç¢¼...', 'info');
                progressText.textContent = 'æ­£åœ¨ç·¨ç¢¼...';
            }

            try {
                let encodedString = '';
                let base64Carry = new Uint8Array(0);
                let base32Carry = new Uint8Array(0);
                const hexTable = Array.from({ length: 256 }, (_, i) =>
                    i.toString(16).padStart(2, '0')
                );

                for await (const chunk of FileProcessor.processInChunks(
                    file,
                    chunkSize,
                    (progress) => {
                        progressFill.style.width = `${progress}%`;
                        progressText.textContent = `è™•ç†ä¸­: ${Math.round(progress)}%`;
                    }
                )) {
                    let dataChunk = chunk;
                    if (enableCompression) {
                        dataChunk = await compressChunk(chunk);
                    }

                    switch (format) {
                        case 'base64': {
                            const res = encodeBase64Chunk(dataChunk, base64Carry);
                            encodedString += res.output;
                            base64Carry = res.carry;
                            break;
                        }
                        case 'hex':
                            for (let i = 0; i < dataChunk.length; i++) {
                                encodedString += hexTable[dataChunk[i]];
                            }
                            break;
                        case 'base32': {
                            const res = encodeBase32Chunk(dataChunk, base32Carry);
                            encodedString += res.output;
                            base32Carry = res.carry;
                            break;
                        }
                        default:
                            throw new Error('ä¸æ”¯æ´çš„ç·¨ç¢¼æ ¼å¼');
                    }
                }

                if (format === 'base64') {
                    encodedString += finalizeBase64(base64Carry);
                } else if (format === 'base32') {
                    encodedString += finalizeBase32(base32Carry);
                }

                progressFill.style.width = '100%';
                progressText.textContent = 'ç·¨ç¢¼å®Œæˆ!';
                
                if (addTimestamp) {
                    const timestamp = new Date().toISOString();
                    encodedString = `[${timestamp}]\n${encodedString}`;
                }

                const enableEncryption = document.getElementById('enableEncryption').checked;
                if (enableEncryption) {
                    const password = document.getElementById('encryptionPassword').value;
                    if (!password) {
                        throw new Error('è«‹è¼¸å…¥å¯†ç¢¼');
                    }
                    const encryptedBuffer = await encryptData(new TextEncoder().encode(encodedString), password);
                    encodedString = await arrayBufferToBase64(encryptedBuffer);
                }

                encodedString = JSON.stringify({ filename: file.name, data: encodedString });

                document.getElementById('encodedText').value = encodedString;
                showStatus('encodeStatus', 'âœ… ç·¨ç¢¼å®Œæˆï¼', 'success');
                showToast('ç·¨ç¢¼æˆåŠŸå®Œæˆï¼', 'success');
                
                // é¡¯ç¤ºçµ±è¨ˆè³‡è¨Š
                const processingTime = (Date.now() - processingStartTime) / 1000;
                showEncodeStats(file.size, encodedString.length, processingTime);
                
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                if (error.message === 'æ“ä½œå·²å–æ¶ˆ') {
                    showStatus('encodeStatus', 'â¹ï¸ æ“ä½œå·²å–æ¶ˆ', 'warning');
                    showToast('æ“ä½œå·²å–æ¶ˆ', 'info');
                } else {
                    showStatus('encodeStatus', 'âŒ ç·¨ç¢¼å¤±æ•—ï¼š' + error.message, 'error');
                    showToast('ç·¨ç¢¼å¤±æ•—', 'error');
                }
                progressContainer.style.display = 'none';
            } finally {
                encodeBtn.disabled = false;
                encodeBtn.innerHTML = 'ğŸ” é–‹å§‹ç·¨ç¢¼';
                encodeBtn.onclick = encodeFile;
            }
        }

        function arrayBufferToBase64(buffer) {
            return new Promise((resolve) => {
                const blob = new Blob([buffer]);
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result.split(',')[1];
                    resolve(base64);
                };
                reader.readAsDataURL(blob);
            });
        }

        function arrayBufferToHex(buffer) {
            const uint8Array = new Uint8Array(buffer);
            return Array.from(uint8Array, byte => byte.toString(16).padStart(2, '0')).join('');
        }

        function showEncodeStats(originalSize, encodedSize, processingTime) {
            document.getElementById('originalSize').textContent = originalSize.toLocaleString();
            document.getElementById('encodedSize').textContent = encodedSize.toLocaleString();
            document.getElementById('sizeRatio').textContent = Math.round((encodedSize / originalSize) * 100) + '%';
            document.getElementById('processingTime').textContent = processingTime.toFixed(2);
            document.getElementById('encodeStats').style.display = 'grid';
        }

        async function decodeText() {
            const decodeTextArea = document.getElementById('decodeText');
            let encodedText = decodeTextArea.value.trim();

            if (!encodedText) {
                showStatus('decodeStatus', 'âŒ è«‹è¼¸å…¥è¦è§£ç¢¼çš„æ–‡å­—', 'error');
                return;
            }

            try {
                const parsed = JSON.parse(encodedText);
                if (parsed && typeof parsed === 'object' && 'filename' in parsed && 'data' in parsed) {
                    originalFileName = parsed.filename;
                    encodedText = parsed.data;
                }
            } catch (e) {}

            const enableDecryption = document.getElementById('enableDecryption').checked;
            if (enableDecryption) {
                const password = document.getElementById('decryptionPassword').value;
                if (!password) {
                    showStatus('decodeStatus', 'âŒ è«‹è¼¸å…¥å¯†ç¢¼', 'error');
                    return;
                }
                try {
                    const encryptedBuffer = base64ToArrayBuffer(encodedText);
                    const decryptedBuffer = await decryptData(encryptedBuffer, password);
                    encodedText = new TextDecoder().decode(decryptedBuffer);
                } catch (e) {
                    showStatus('decodeStatus', 'âŒ è§£å¯†å¤±æ•—ï¼šå¯†ç¢¼éŒ¯èª¤æˆ–è³‡æ–™ææ¯€', 'error');
                    return;
                }
            }

            // ç§»é™¤æ™‚é–“æˆ³è¨˜ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
            const timestampMatch = encodedText.match(/^\[([^\]]+)\]\n(.*)$/s);
            if (timestampMatch) {
                encodedText = timestampMatch[2];
                showToast('åµæ¸¬åˆ°æ™‚é–“æˆ³è¨˜ï¼š' + timestampMatch[1], 'info');
            }

            let format = document.querySelector('input[name="decodeFormat"]:checked').value;
            const validateIntegrity = document.getElementById('validateIntegrity').checked;
            const autoDetect = document.getElementById('autoDetectFormat').checked;
            const autoDecompress = document.getElementById('decompressGzip').checked;
            
            if (format === 'auto' || autoDetect) {
                format = FileProcessor.detectFormat(encodedText);
                if (format === 'unknown') {
                    showStatus('decodeStatus', 'âŒ ç„¡æ³•è‡ªå‹•åµæ¸¬ç·¨ç¢¼æ ¼å¼', 'error');
                    return;
                }
                showToast('è‡ªå‹•åµæ¸¬æ ¼å¼ï¼š' + format.toUpperCase(), 'info');
            }

            processingStartTime = Date.now();
            currentAbortController = new AbortController();
            
            const progressContainer = document.getElementById('decodeProgressContainer');
            const progressFill = document.getElementById('decodeProgressFill');
            const progressText = document.getElementById('decodeProgressText');
            const decodeBtn = document.getElementById('decodeBtn');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            decodeBtn.disabled = true;
            decodeBtn.innerHTML = 'â¹ï¸ å–æ¶ˆè™•ç†';
            decodeBtn.onclick = () => {
                currentAbortController.abort();
                decodeBtn.disabled = false;
                decodeBtn.innerHTML = 'ğŸ”“ é–‹å§‹è§£ç¢¼';
                decodeBtn.onclick = decodeText;
                progressContainer.style.display = 'none';
            };
            
            showStatus('decodeStatus', autoDecompress ? 'ğŸ”“ æ­£åœ¨è§£ç¢¼ä¸¦è§£å£“...' : 'ğŸ”“ æ­£åœ¨è§£ç¢¼...', 'info');

            try {
                progressText.textContent = 'è§£æç·¨ç¢¼æ ¼å¼...';
                progressFill.style.width = '25%';
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const decompressBuffer = async (buffer) => {
                    if (typeof DecompressionStream !== 'undefined') {
                        const ds = new DecompressionStream('gzip');
                        const writer = ds.writable.getWriter();
                        await writer.write(buffer);
                        await writer.close();
                        return await new Response(ds.readable).arrayBuffer();
                    }
                    throw new Error('ç€è¦½å™¨ä¸æ”¯æ´ gzip è§£å£“ç¸®');
                };

                let arrayBuffer;
                switch (format) {
                    case 'base64':
                        arrayBuffer = base64ToArrayBuffer(encodedText);
                        break;
                    case 'hex':
                        arrayBuffer = hexToArrayBuffer(encodedText);
                        break;
                    case 'base32':
                        arrayBuffer = base32ToArrayBuffer(encodedText);
                        break;
                    default:
                        throw new Error('ä¸æ”¯æ´çš„è§£ç¢¼æ ¼å¼ï¼š' + format);
                }

                const uint8 = new Uint8Array(arrayBuffer);
                if (autoDecompress || (uint8[0] === 0x1f && uint8[1] === 0x8b)) {
                    showStatus('decodeStatus', 'ğŸ”“ æ­£åœ¨è§£ç¢¼ä¸¦è§£å£“...', 'info');
                    progressFill.style.width = '50%';
                    progressText.textContent = 'æ­£åœ¨è§£å£“ç¸®...';
                    try {
                        arrayBuffer = await decompressBuffer(uint8);
                        showToast('å·²é€²è¡Œ gzip è§£å£“', 'info');
                    } catch (e) {
                        throw new Error('è§£å£“ç¸®å¤±æ•—ï¼š' + e.message);
                    }
                }

                progressFill.style.width = '75%';
                progressText.textContent = 'é©—è­‰è³‡æ–™å®Œæ•´æ€§...';

                if (validateIntegrity && arrayBuffer.byteLength === 0) {
                    throw new Error('è§£ç¢¼å¾Œè³‡æ–™ç‚ºç©º');
                }

                progressFill.style.width = '100%';
                progressText.textContent = 'è§£ç¢¼å®Œæˆ!';
                
                decodedData = arrayBuffer;
                showStatus('decodeStatus', 'âœ… è§£ç¢¼å®Œæˆï¼', 'success');
                showToast('è§£ç¢¼æˆåŠŸå®Œæˆï¼', 'success');
                
                // é¡¯ç¤ºçµ±è¨ˆè³‡è¨Š
                const processingTime = (Date.now() - processingStartTime) / 1000;
                showDecodeStats(arrayBuffer.byteLength, processingTime);
                
                document.getElementById('decodeButtons').style.display = 'block';
                
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                if (error.message === 'æ“ä½œå·²å–æ¶ˆ') {
                    showStatus('decodeStatus', 'â¹ï¸ æ“ä½œå·²å–æ¶ˆ', 'warning');
                    showToast('æ“ä½œå·²å–æ¶ˆ', 'info');
                } else {
                    showStatus('decodeStatus', 'âŒ è§£ç¢¼å¤±æ•—ï¼š' + error.message, 'error');
                    showToast('è§£ç¢¼å¤±æ•—', 'error');
                }
                progressContainer.style.display = 'none';
            } finally {
                decodeBtn.disabled = false;
                decodeBtn.innerHTML = 'ğŸ”“ é–‹å§‹è§£ç¢¼';
                decodeBtn.onclick = decodeText;
            }
        }

        function base64ToArrayBuffer(base64) {
            try {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (error) {
                throw new Error('ç„¡æ•ˆçš„Base64æ ¼å¼');
            }
        }

        function hexToArrayBuffer(hex) {
            if (hex.length % 2 !== 0) {
                throw new Error('åå…­é€²ä½å­—ä¸²é•·åº¦å¿…é ˆæ˜¯å¶æ•¸');
            }
            
            try {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    const byte = parseInt(hex.substr(i, 2), 16);
                    if (isNaN(byte)) {
                        throw new Error('ç„¡æ•ˆçš„åå…­é€²ä½å­—å…ƒ');
                    }
                    bytes[i / 2] = byte;
                }
                return bytes.buffer;
            } catch (error) {
                throw new Error('ç„¡æ•ˆçš„åå…­é€²ä½æ ¼å¼');
            }
        }

        function showDecodeStats(size, processingTime) {
            document.getElementById('decodedSize').textContent = size.toLocaleString();
            document.getElementById('decodedType').textContent = detectFileType(new Uint8Array(decodedData));
            document.getElementById('decodeTime').textContent = processingTime.toFixed(2);
            document.getElementById('decodeStats').style.display = 'grid';
        }

        function detectFileType(uint8Array) {
            if (uint8Array.length < 4) return 'Unknown';
            
            const getSignature = (length) => {
                return Array.from(uint8Array.slice(0, length), byte => 
                    byte.toString(16).padStart(2, '0')).join('');
            };
            
            const signatures = {
                '89504e47': 'PNG åœ–ç‰‡',
                'ffd8ffe0': 'JPEG åœ–ç‰‡', 'ffd8ffe1': 'JPEG åœ–ç‰‡', 'ffd8ffe2': 'JPEG åœ–ç‰‡',
                '47494638': 'GIF åœ–ç‰‡',
                '25504446': 'PDF æ–‡ä»¶',
                '504b0304': 'ZIP/Office æ–‡ä»¶', '504b0506': 'ZIP/Office æ–‡ä»¶',
                'd0cf11e0': 'MS Office æ–‡ä»¶',
                '52617221': 'RAR å£“ç¸®æª”',
                '7f454c46': 'ELF åŸ·è¡Œæª”',
                '4d5a9000': 'EXE åŸ·è¡Œæª”', '4d5a9001': 'EXE åŸ·è¡Œæª”',
                '3c68746d': 'HTML æ–‡ä»¶', '3c21444f': 'HTML æ–‡ä»¶',
                '3c3f786d': 'XML æ–‡ä»¶',
                '377abcaf': '7Z å£“ç¸®æª”',
                '1f8b0800': 'GZIP æª”æ¡ˆ',
                '425a6839': 'BZIP2 æª”æ¡ˆ',
                '49443303': 'MP3 éŸ³æ¨‚', '49443304': 'MP3 éŸ³æ¨‚',
                '52494646': 'WAV éŸ³æ¨‚',
                '00000014': 'MP4 å½±ç‰‡', '00000018': 'MP4 å½±ç‰‡', '0000001c': 'MP4 å½±ç‰‡',
            };
            
            const signature4 = getSignature(4);
            const signature8 = getSignature(8);
            
            // æª¢æŸ¥8ä½å…ƒçµ„ç°½å
            for (const [sig, type] of Object.entries(signatures)) {
                if (sig.length === 8 && signature8.startsWith(sig)) {
                    return type;
                }
            }
            
            // æª¢æŸ¥4ä½å…ƒçµ„ç°½å
            for (const [sig, type] of Object.entries(signatures)) {
                if (sig.length === 8 && signature4.startsWith(sig)) {
                    return type;
                }
            }
            
            // æ–‡å­—æª”æª¢æ¸¬
            if (isTextFile(uint8Array)) {
                return 'Text æ–‡å­—æª”';
            }
            
            return 'Unknown';
        }

        function isTextFile(uint8Array) {
            const sample = uint8Array.slice(0, Math.min(1024, uint8Array.length));
            let textChars = 0;
            
            for (const byte of sample) {
                if ((byte >= 32 && byte <= 126) || byte === 9 || byte === 10 || byte === 13) {
                    textChars++;
                }
            }
            
            return textChars / sample.length > 0.95;
        }

        async function validateEncoded() {
            let encodedText = document.getElementById('encodedText').value;
            if (!encodedText) {
                showStatus('encodeStatus', 'âŒ æ²’æœ‰ç·¨ç¢¼çµæœå¯é©—è­‰', 'error');
                return;
            }

            try {
                const parsed = JSON.parse(encodedText);
                if (parsed && typeof parsed === 'object' && 'data' in parsed) {
                    encodedText = parsed.data;
                }
            } catch (e) {}

            const format = document.querySelector('input[name="encodeFormat"]:checked').value;
            
            try {
                showStatus('encodeStatus', 'ğŸ” æ­£åœ¨é©—è­‰ç·¨ç¢¼...', 'info');
                
                let arrayBuffer;
                switch (format) {
                    case 'base64':
                        arrayBuffer = base64ToArrayBuffer(encodedText);
                        break;
                    case 'hex':
                        arrayBuffer = hexToArrayBuffer(encodedText);
                        break;
                    case 'base32':
                        arrayBuffer = base32ToArrayBuffer(encodedText);
                        break;
                }
                
                const fileInput = document.getElementById('encodeFile');
                if (fileInput.files.length > 0) {
                    const originalBuffer = await fileInput.files[0].arrayBuffer();
                    const isValid = FileProcessor.validateIntegrity(originalBuffer, arrayBuffer);
                    
                    if (isValid) {
                        showStatus('encodeStatus', 'âœ… ç·¨ç¢¼é©—è­‰é€šéï¼è³‡æ–™å®Œæ•´ç„¡èª¤', 'success');
                        showToast('ç·¨ç¢¼é©—è­‰æˆåŠŸï¼', 'success');
                    } else {
                        showStatus('encodeStatus', 'âš ï¸ ç·¨ç¢¼é©—è­‰å¤±æ•—ï¼è³‡æ–™å¯èƒ½æœ‰èª¤', 'error');
                        showToast('ç·¨ç¢¼é©—è­‰å¤±æ•—ï¼', 'error');
                    }
                } else {
                    showStatus('encodeStatus', 'âœ… ç·¨ç¢¼æ ¼å¼é©—è­‰é€šé', 'success');
                    showToast('æ ¼å¼é©—è­‰é€šéï¼', 'success');
                }
                
            } catch (error) {
                showStatus('encodeStatus', 'âŒ é©—è­‰å¤±æ•—ï¼š' + error.message, 'error');
                showToast('é©—è­‰å¤±æ•—', 'error');
            }
        }

        function copyEncoded() {
            const encodedText = document.getElementById('encodedText');
            if (!encodedText.value) {
                showStatus('encodeStatus', 'âŒ æ²’æœ‰ç·¨ç¢¼çµæœå¯è¤‡è£½', 'error');
                return;
            }
            
            encodedText.select();
            document.execCommand('copy');
            showStatus('encodeStatus', 'âœ… ç·¨ç¢¼çµæœå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿', 'success');
            showToast('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼', 'success');
        }

        function downloadEncoded() {
            const encodedText = document.getElementById('encodedText').value;
            if (!encodedText) {
                showStatus('encodeStatus', 'âŒ æ²’æœ‰ç·¨ç¢¼çµæœå¯ä¸‹è¼‰', 'error');
                return;
            }
            
            const format = document.querySelector('input[name="encodeFormat"]:checked').value;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = originalFileName ?
                `${originalFileName.replace(/\.[^/.]+$/, '')}_encoded_${format}_${timestamp}.json` :
                `encoded_${format}_${timestamp}.json`;

            const blob = new Blob([encodedText], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('encodeStatus', 'âœ… ç·¨ç¢¼çµæœå·²ä¸‹è¼‰', 'success');
            showToast('æª”æ¡ˆä¸‹è¼‰å®Œæˆï¼', 'success');
        }

        function loadFromFile() {
            const hiddenFileInput = document.getElementById('hiddenFileInput');
            hiddenFileInput.accept = '.json,.txt,.dat,.base64,.hex';
            hiddenFileInput.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        document.getElementById('decodeText').value = e.target.result;
                        showToast(`å·²è¼‰å…¥æª”æ¡ˆï¼š${file.name}`, 'success');
                    };
                    reader.readAsText(file);
                }
            };
            hiddenFileInput.click();
        }

        async function downloadDecoded() {
            if (!decodedData) {
                showStatus('decodeStatus', 'âŒ æ²’æœ‰è§£ç¢¼çµæœå¯ä¸‹è¼‰', 'error');
                return;
            }
            
            const fileType = detectFileType(new Uint8Array(decodedData));
            const extension = getFileExtension(fileType);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = originalFileName || `decoded_file_${timestamp}${extension}`;
            
            const blob = new Blob([decodedData]);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('decodeStatus', 'âœ… è§£ç¢¼æª”æ¡ˆå·²ä¸‹è¼‰', 'success');
            showToast('æª”æ¡ˆä¸‹è¼‰å®Œæˆï¼', 'success');
        }

        function saveAsDecoded() {
            if (!decodedData) {
                showStatus('decodeStatus', 'âŒ æ²’æœ‰è§£ç¢¼çµæœå¯å„²å­˜', 'error');
                return;
            }
            
            // åˆ†ææª”æ¡ˆè³‡è¨Š
            const fileType = detectFileType(new Uint8Array(decodedData));
            const fileSize = formatBytes(decodedData.byteLength);
            const suggestedExtension = getFileExtension(fileType);
            
            // å¡«å…¥æª”æ¡ˆé è¦½è³‡è¨Š
            document.getElementById('previewFileType').textContent = fileType;
            document.getElementById('previewFileSize').textContent = fileSize;
            document.getElementById('previewFileFormat').textContent = suggestedExtension;
            
            // è¨­å®šé è¨­æª”æ¡ˆåç¨±
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 16);
            const defaultName = originalFileName ? 
                originalFileName.replace(/\.[^/.]+$/, '') : 
                `decoded_file_${timestamp}`;
            document.getElementById('saveFileName').value = defaultName;
            
            // è¨­å®šå»ºè­°çš„å‰¯æª”å
            const extensionSelect = document.getElementById('saveFileExtension');
            const matchingOption = Array.from(extensionSelect.options).find(option => 
                option.value === suggestedExtension
            );
            if (matchingOption) {
                extensionSelect.value = suggestedExtension;
            } else {
                extensionSelect.value = 'auto';
            }
            
            // é¡¯ç¤ºå½ˆå‡ºè¦–çª—
            document.getElementById('saveAsModal').classList.add('show');
            document.getElementById('saveFileName').focus();
            document.getElementById('saveFileName').select();
        }

        function closeSaveAsModal() {
            document.getElementById('saveAsModal').classList.remove('show');
        }

        function confirmSaveAs() {
            const fileName = document.getElementById('saveFileName').value.trim();
            const selectedExtension = document.getElementById('saveFileExtension').value;
            
            if (!fileName) {
                showToast('è«‹è¼¸å…¥æª”æ¡ˆåç¨±', 'error');
                return;
            }
            
            let finalFileName = fileName;
            
            // è™•ç†å‰¯æª”å
            if (selectedExtension === 'auto') {
                // è‡ªå‹•åµæ¸¬å‰¯æª”å
                const fileType = detectFileType(new Uint8Array(decodedData));
                const autoExtension = getFileExtension(fileType);
                if (autoExtension && !finalFileName.includes('.')) {
                    finalFileName += autoExtension;
                }
            } else if (selectedExtension) {
                // ä½¿ç”¨é¸å®šçš„å‰¯æª”å
                if (!finalFileName.endsWith(selectedExtension)) {
                    // ç§»é™¤ç¾æœ‰å‰¯æª”åï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
                    finalFileName = finalFileName.replace(/\.[^/.]+$/, '');
                    finalFileName += selectedExtension;
                }
            }
            
            // é©—è­‰æª”æ¡ˆåç¨±
            const invalidChars = /[<>:"/\\|?*]/g;
            if (invalidChars.test(finalFileName)) {
                showToast('æª”æ¡ˆåç¨±åŒ…å«ç„¡æ•ˆå­—å…ƒ', 'error');
                return;
            }
            
            // ä¸‹è¼‰æª”æ¡ˆ
            try {
                const blob = new Blob([decodedData]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = finalFileName;
                a.click();
                URL.revokeObjectURL(url);
                
                closeSaveAsModal();
                showStatus('decodeStatus', `âœ… æª”æ¡ˆå·²å„²å­˜ç‚º: ${finalFileName}`, 'success');
                showToast('æª”æ¡ˆå„²å­˜å®Œæˆï¼', 'success');
                
                // è¨˜éŒ„ä¸‹è¼‰æ­·å²ï¼ˆå¯é¸ï¼‰
                recordDownloadHistory(finalFileName, decodedData.byteLength);
                
            } catch (error) {
                showToast('æª”æ¡ˆå„²å­˜å¤±æ•—: ' + error.message, 'error');
            }
        }

        function recordDownloadHistory(filename, size) {
            try {
                const history = JSON.parse(localStorage.getItem('downloadHistory') || '[]');
                history.unshift({
                    filename,
                    size,
                    timestamp: new Date().toISOString(),
                    type: detectFileType(new Uint8Array(decodedData))
                });
                
                // åªä¿ç•™æœ€è¿‘10æ¬¡è¨˜éŒ„
                if (history.length > 10) {
                    history.splice(10);
                }
                
                localStorage.setItem('downloadHistory', JSON.stringify(history));
            } catch (error) {
                console.warn('ç„¡æ³•å„²å­˜ä¸‹è¼‰æ­·å²:', error);
            }
        }

        function previewDecoded() {
            if (!decodedData) {
                showStatus('decodeStatus', 'âŒ æ²’æœ‰è§£ç¢¼çµæœå¯é è¦½', 'error');
                return;
            }
            
            const fileType = detectFileType(new Uint8Array(decodedData));
            const blob = new Blob([decodedData]);
            const url = URL.createObjectURL(blob);
            
            if (fileType.includes('åœ–ç‰‡') || fileType.includes('PDF') || fileType.includes('æ–‡å­—')) {
                window.open(url, '_blank');
                showToast('æª”æ¡ˆé è¦½å·²é–‹å•Ÿ', 'info');
            } else {
                showStatus('decodeStatus', 'âš ï¸ è©²æª”æ¡ˆé¡å‹ä¸æ”¯æ´é è¦½', 'warning');
                showToast('ä¸æ”¯æ´é è¦½æ­¤æª”æ¡ˆé¡å‹', 'warning');
            }
            
            setTimeout(() => URL.revokeObjectURL(url), 60000);
        }

        function getFileExtension(fileType) {
            const extensions = {
                'PNG åœ–ç‰‡': '.png', 'JPEG åœ–ç‰‡': '.jpg', 'GIF åœ–ç‰‡': '.gif',
                'PDF æ–‡ä»¶': '.pdf', 'MS Office æ–‡ä»¶': '.doc', 'ZIP/Office æ–‡ä»¶': '.zip',
                'RAR å£“ç¸®æª”': '.rar', '7Z å£“ç¸®æª”': '.7z', 'GZIP æª”æ¡ˆ': '.gz',
                'ELF åŸ·è¡Œæª”': '.elf', 'EXE åŸ·è¡Œæª”': '.exe',
                'HTML æ–‡ä»¶': '.html', 'XML æ–‡ä»¶': '.xml', 'Text æ–‡å­—æª”': '.txt',
                'MP3 éŸ³æ¨‚': '.mp3', 'WAV éŸ³æ¨‚': '.wav', 'MP4 å½±ç‰‡': '.mp4'
            };
            return extensions[fileType] || '.bin';
        }

        function clearEncode() {
            document.getElementById('encodeFile').value = '';
            document.getElementById('encodedText').value = '';
            document.getElementById('encodeFileInfo').style.display = 'none';
            document.getElementById('encodeStatus').innerHTML = '';
            document.getElementById('encodeStats').style.display = 'none';
            document.getElementById('encodeProgressContainer').style.display = 'none';
            originalFileName = '';
            
            // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
            const encodeBtn = document.getElementById('encodeBtn');
            encodeBtn.disabled = false;
            encodeBtn.innerHTML = 'ğŸ” é–‹å§‹ç·¨ç¢¼';
            encodeBtn.onclick = encodeFile;
            
            if (currentAbortController) {
                currentAbortController.abort();
            }
            
            showToast('ç·¨ç¢¼å€åŸŸå·²æ¸…é™¤', 'info');
        }

        function clearDecode() {
            document.getElementById('decodeText').value = '';
            document.getElementById('decodeStatus').innerHTML = '';
            document.getElementById('decodeButtons').style.display = 'none';
            document.getElementById('decodeStats').style.display = 'none';
            document.getElementById('decodeProgressContainer').style.display = 'none';
            decodedData = null;
            
            // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
            const decodeBtn = document.getElementById('decodeBtn');
            decodeBtn.disabled = false;
            decodeBtn.innerHTML = 'ğŸ”“ é–‹å§‹è§£ç¢¼';
            decodeBtn.onclick = decodeText;
            
            if (currentAbortController) {
                currentAbortController.abort();
            }
            
            showToast('è§£ç¢¼å€åŸŸå·²æ¸…é™¤', 'info');
        }

        function showStatus(elementId, message, type) {
            const statusElement = document.getElementById(elementId);
            const iconMap = {
                success: 'âœ…',
                error: 'âŒ',
                info: 'â„¹ï¸',
                warning: 'âš ï¸'
            };
            
            statusElement.innerHTML = `
                <div class="status-message status-${type}">
                    ${iconMap[type] || ''} ${message}
                </div>
            `;
            
            // è‡ªå‹•æ¸…é™¤æˆåŠŸå’ŒéŒ¯èª¤è¨Šæ¯
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    if (statusElement.innerHTML.includes(message)) {
                        statusElement.innerHTML = '';
                    }
                }, 5000);
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => document.body.removeChild(toast), 300);
            }, 3000);
        }

        function toggleAdvanced(section) {
            const content = document.getElementById(section + 'Advanced');
            const icon = document.getElementById(section + 'AdvancedIcon');
            
            if (content.classList.contains('show')) {
                content.classList.remove('show');
                icon.textContent = 'â–¼';
            } else {
                content.classList.add('show');
                icon.textContent = 'â–²';
            }
        }

        // éµç›¤å¿«æ·éµæ”¯æ´
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'e':
                        e.preventDefault();
                        encodeFile();
                        break;
                    case 'd':
                        e.preventDefault();
                        decodeText();
                        break;
                    case 'r':
                        e.preventDefault();
                        clearEncode();
                        clearDecode();
                        break;
                    case 's':
                        if (decodedData) {
                            e.preventDefault();
                            saveAsDecoded();
                        }
                        break;
                }
            }
            
            if (e.key === 'Escape') {
                if (currentAbortController) {
                    currentAbortController.abort();
                }
                closeSaveAsModal();
            }
            
            // Enter éµç¢ºèªå¦å­˜æ–°æª”
            if (e.key === 'Enter' && document.getElementById('saveAsModal').classList.contains('show')) {
                e.preventDefault();
                confirmSaveAs();
            }
        });

        // é»æ“Šå½ˆå‡ºè¦–çª—å¤–éƒ¨é—œé–‰
        document.getElementById('saveAsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeSaveAsModal();
            }
        });

        // è‡ªå‹•å„²å­˜åŠŸèƒ½
        function saveToLocalStorage() {
            try {
                const data = {
                    encodedText: document.getElementById('encodedText').value,
                    decodeText: document.getElementById('decodeText').value,
                    timestamp: Date.now()
                };
                localStorage.setItem('fileEncoderData', JSON.stringify(data));
            } catch (error) {
                console.warn('ç„¡æ³•å„²å­˜åˆ°æœ¬åœ°å„²å­˜:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const data = JSON.parse(localStorage.getItem('fileEncoderData'));
                if (data && Date.now() - data.timestamp < 24 * 60 * 60 * 1000) { // 24å°æ™‚å…§
                    if (data.encodedText) {
                        document.getElementById('encodedText').value = data.encodedText;
                    }
                    if (data.decodeText) {
                        document.getElementById('decodeText').value = data.decodeText;
                    }
                }
            } catch (error) {
                console.warn('ç„¡æ³•å¾æœ¬åœ°å„²å­˜è¼‰å…¥:', error);
            }
        }

        // æ•ˆèƒ½ç›£æ§
        class PerformanceMonitor {
            static startTimer(name) {
                this.timers = this.timers || {};
                this.timers[name] = performance.now();
            }
            
            static endTimer(name) {
                if (this.timers && this.timers[name]) {
                    const duration = performance.now() - this.timers[name];
                    console.log(`${name}: ${duration.toFixed(2)}ms`);
                    delete this.timers[name];
                    return duration;
                }
                return 0;
            }
            
            static getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                }
                return null;
            }
        }

        // æ–‡å­—å€åŸŸè‡ªå‹•èª¿æ•´é«˜åº¦
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 400) + 'px';
        }

        // ç‚ºæ–‡å­—å€åŸŸæ·»åŠ è‡ªå‹•èª¿æ•´åŠŸèƒ½
        document.getElementById('encodedText').addEventListener('input', function() {
            autoResizeTextarea(this);
            saveToLocalStorage();
        });

        document.getElementById('decodeText').addEventListener('input', function() {
            autoResizeTextarea(this);
            saveToLocalStorage();
        });

        // æ‰¹æ¬¡è™•ç†åŠŸèƒ½
        async function batchProcessFiles(files, operation) {
            const results = [];
            const totalFiles = files.length;
            
            for (let i = 0; i < totalFiles; i++) {
                const file = files[i];
                try {
                    showStatus('encodeStatus', `è™•ç†æª”æ¡ˆ ${i + 1}/${totalFiles}: ${file.name}`, 'info');
                    const result = await operation(file);
                    results.push({ file: file.name, success: true, result });
                } catch (error) {
                    results.push({ file: file.name, success: false, error: error.message });
                }
            }
            
            return results;
        }

        // æª”æ¡ˆå®Œæ•´æ€§æª¢æŸ¥
        function calculateChecksum(arrayBuffer) {
            const uint8Array = new Uint8Array(arrayBuffer);
            let checksum = 0;
            for (let i = 0; i < uint8Array.length; i++) {
                checksum = (checksum + uint8Array[i]) % 65536;
            }
            return checksum.toString(16).padStart(4, '0');
        }

        // å¢å¼·çš„éŒ¯èª¤è™•ç†
        window.addEventListener('error', function(e) {
            console.error('å…¨åŸŸéŒ¯èª¤:', e.error);
            showToast('ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤ï¼Œè«‹é‡æ–°æ•´ç†é é¢', 'error');
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('æœªè™•ç†çš„Promiseæ‹’çµ•:', e.reason);
            showToast('è™•ç†éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤', 'error');
        });

        // é é¢è¼‰å…¥å®Œæˆå¾Œçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // è¼‰å…¥å…ˆå‰çš„è³‡æ–™
            loadFromLocalStorage();
            
            // é¡¯ç¤ºç‰ˆæœ¬è³‡è¨Š
            console.log('æª”æ¡ˆç·¨ç¢¼è§£ç¢¼å·¥å…· - å°ˆæ¥­ç‰ˆ v2.0');
            console.log('æ”¯æ´æ ¼å¼: Base64, Hex, Base32');
            console.log('æ–°åŠŸèƒ½: å¤§æª”æ¡ˆè™•ç†, æ‰¹æ¬¡æ“ä½œ, å®Œæ•´æ€§é©—è­‰');
            
            // æª¢æŸ¥ç€è¦½å™¨åŠŸèƒ½æ”¯æ´
            if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                showToast('æ‚¨çš„ç€è¦½å™¨ä¸å®Œå…¨æ”¯æ´æª”æ¡ˆAPIåŠŸèƒ½', 'warning');
            }
            
            // é¡¯ç¤ºæ­¡è¿è¨Šæ¯
            showToast('æª”æ¡ˆç·¨ç¢¼è§£ç¢¼å·¥å…·å·²å°±ç·’ï¼', 'success');
        });

        // é é¢å¸è¼‰å‰å„²å­˜è³‡æ–™
        window.addEventListener('beforeunload', function() {
            saveToLocalStorage();
        });

        // éŸ¿æ‡‰å¼è™•ç†
        function handleResponsive() {
            const container = document.querySelector('.main-content');
            if (window.innerWidth <= 768) {
                container.style.gridTemplateColumns = '1fr';
            } else {
                container.style.gridTemplateColumns = '1fr 1fr';
            }
        }

        window.addEventListener('resize', handleResponsive);

        // æ·±è‰²æ¨¡å¼åˆ‡æ›ï¼ˆå¦‚æœéœ€è¦ï¼‰
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            showToast(isDark ? 'å·²åˆ‡æ›åˆ°æ·±è‰²æ¨¡å¼' : 'å·²åˆ‡æ›åˆ°æ·ºè‰²æ¨¡å¼', 'info');
        }

        // åŒ¯å‡ºæ‰€æœ‰åŠŸèƒ½åˆ°å…¨åŸŸç¯„åœï¼ˆç”¨æ–¼æ§åˆ¶å°é™¤éŒ¯ï¼‰
        if (typeof window !== 'undefined') {
            window.FileEncoderUtils = {
                FileProcessor,
                PerformanceMonitor,
                calculateChecksum,
                toggleDarkMode,
                clearAll: () => { clearEncode(); clearDecode(); },
                version: '2.0'
            };
        }
    </script>
</body>
</html>
